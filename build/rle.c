/* Generated by re2c 2.1.1 on Mon Oct 11 14:59:06 2021 */
#line 1 "misc/rle.r2c"
#include <ctype.h>
#include <errno.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "rules.h"

typedef struct {
	const char* top;	//start of token
	const char* curr;	//cursor; will be just past token when emitting tokens
	const char* ptr;	//used by re2c to store position for backtracking
	const char* pos;	//
	int line;		//line no in source file
	int current_token;
} scanner;

typedef enum {
  NAME,
  AUTHOR,
  XY_RULE,
  INVALID,
} hash_token_type;

typedef struct {
  hash_token_type type;
  char *next;
  union {
    char *name;
    char *author;
    struct {
      unsigned long x;
      unsigned long y;
      char *s;
      char *b;
    };
  };
} hash_token;

static char *mk_string(char *start, char *cursor) {
  int len = cursor - start - 1;
  char *res = malloc(len);
  memcpy(res, start, len);
  res[len] = '\0';
  return res;
}

long parse_int(char *s) {
  bool neg = false;
  long res = 0;
  while (*s++ == '-') neg = !neg;
  while (isdigit(*s)) {
    res *= 10;
    res += s - '0';
    s++;
  }
  return res;
}

hash_token scan_header(const char *YYCURSOR) {
  char *YYMARKER;
  // union {
  //   struct { char *name, *ename; };
  //   struct { char *author, *eauthor; };
  //   struct { char *x, *y, *rule, *ex, *ey, *erule; };
  // } positions;
  char *name, *ename;
  char *author, *eauthor;
  char *x, *y, *ex, *ey;
  char *s, *b, *es, *eb;
  char *s2, *b2, *es2, *eb2;
  const char *yyt1; const char *yyt10; const char *yyt2; const char *yyt3; const char *yyt4; const char *yyt5; const char *yyt6; const char *yyt7; const char *yyt8; const char *yyt9; 
  hash_token token;
  token.type = INVALID;
loop:

#line 81 "build/rle.c"
{
	char yych;
	yych = *YYCURSOR;
	switch (yych) {
	case '#':	goto yy4;
	case 'x':	goto yy5;
	default:	goto yy2;
	}
yy2:
	++YYCURSOR;
yy3:
#line 92 "misc/rle.r2c"
	{
      token.type = INVALID;
      goto ret;
    }
#line 98 "build/rle.c"
yy4:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'C':
	case 'c':	goto yy6;
	case 'N':	goto yy8;
	case 'O':	goto yy10;
	default:	goto yy3;
	}
yy5:
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case '\t':
	case ' ':	goto yy12;
	case '=':	goto yy15;
	default:	goto yy3;
	}
yy6:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\n':	goto yy17;
	default:	goto yy6;
	}
yy8:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy8;
	case '\n':
		yyt1 = yyt2 = YYCURSOR;
		goto yy21;
	default:
		yyt1 = YYCURSOR;
		goto yy19;
	}
yy10:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy10;
	case '\n':
		yyt1 = yyt2 = YYCURSOR;
		goto yy25;
	default:
		yyt1 = YYCURSOR;
		goto yy23;
	}
yy12:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy12;
	case '=':	goto yy15;
	default:	goto yy14;
	}
yy14:
	YYCURSOR = YYMARKER;
	goto yy3;
yy15:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy15;
	case '-':
		yyt1 = YYCURSOR;
		goto yy27;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
		yyt1 = YYCURSOR;
		goto yy29;
	default:	goto yy14;
	}
yy17:
	++YYCURSOR;
#line 97 "misc/rle.r2c"
	{ printf("skipping comment\n"); goto loop; }
#line 183 "build/rle.c"
yy19:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\n':
		yyt2 = YYCURSOR;
		goto yy21;
	default:	goto yy19;
	}
yy21:
	++YYCURSOR;
	name = yyt1;
	ename = yyt2;
#line 99 "misc/rle.r2c"
	{
      token.type = NAME;
      token.name = mk_string(name, ename);
      goto ret;
    }
#line 202 "build/rle.c"
yy23:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\n':
		yyt2 = YYCURSOR;
		goto yy25;
	default:	goto yy23;
	}
yy25:
	++YYCURSOR;
	author = yyt1;
	eauthor = yyt2;
#line 105 "misc/rle.r2c"
	{
      token.type = AUTHOR;
      token.author = mk_string(author, eauthor);
      goto ret;
    }
#line 221 "build/rle.c"
yy27:
	yych = *++YYCURSOR;
	switch (yych) {
	case '-':	goto yy27;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy29;
	default:	goto yy14;
	}
yy29:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':
		yyt2 = YYCURSOR;
		goto yy31;
	case ',':
		yyt2 = YYCURSOR;
		goto yy33;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy29;
	default:	goto yy14;
	}
yy31:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy31;
	case ',':	goto yy33;
	default:	goto yy14;
	}
yy33:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy33;
	case 'y':	goto yy35;
	default:	goto yy14;
	}
yy35:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy35;
	case '=':	goto yy37;
	default:	goto yy14;
	}
yy37:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy37;
	case '-':
		yyt3 = YYCURSOR;
		goto yy39;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
		yyt3 = YYCURSOR;
		goto yy41;
	default:	goto yy14;
	}
yy39:
	yych = *++YYCURSOR;
	switch (yych) {
	case '-':	goto yy39;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy41;
	default:	goto yy14;
	}
yy41:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':
		yyt4 = YYCURSOR;
		goto yy43;
	case ',':
		yyt4 = YYCURSOR;
		goto yy45;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy41;
	default:	goto yy14;
	}
yy43:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy43;
	case ',':	goto yy45;
	default:	goto yy14;
	}
yy45:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy45;
	case 'R':
	case 'r':	goto yy47;
	default:	goto yy14;
	}
yy47:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'U':
	case 'u':	goto yy48;
	default:	goto yy14;
	}
yy48:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'L':
	case 'l':	goto yy49;
	default:	goto yy14;
	}
yy49:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'E':
	case 'e':	goto yy50;
	default:	goto yy14;
	}
yy50:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy50;
	case '=':	goto yy52;
	default:	goto yy14;
	}
yy52:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy52;
	case 'B':	goto yy54;
	case 'd':
		yyt5 = YYCURSOR;
		goto yy55;
	default:	goto yy14;
	}
yy54:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'd':
		yyt9 = YYCURSOR;
		goto yy57;
	default:	goto yy14;
	}
yy55:
	yych = *++YYCURSOR;
	switch (yych) {
	case '/':	goto yy59;
	case 'd':	goto yy55;
	default:	goto yy14;
	}
yy57:
	yych = *++YYCURSOR;
	switch (yych) {
	case '/':	goto yy60;
	case 'd':	goto yy57;
	default:	goto yy14;
	}
yy59:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'd':
		yyt6 = YYCURSOR;
		goto yy61;
	default:	goto yy14;
	}
yy60:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'S':	goto yy63;
	default:	goto yy14;
	}
yy61:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':
		yyt8 = yyt9 = yyt10 = NULL;
		yyt7 = YYCURSOR;
		goto yy64;
	case '\n':
		yyt8 = yyt9 = yyt10 = NULL;
		yyt7 = YYCURSOR;
		goto yy66;
	case '\r':
		yyt8 = yyt9 = yyt10 = NULL;
		yyt7 = YYCURSOR;
		goto yy68;
	case 'd':	goto yy61;
	default:	goto yy14;
	}
yy63:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'd':
		yyt10 = YYCURSOR;
		goto yy69;
	default:	goto yy14;
	}
yy64:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy64;
	case '\n':	goto yy66;
	case '\r':	goto yy68;
	default:	goto yy14;
	}
yy66:
	++YYCURSOR;
	x = yyt1;
	ex = yyt2;
	y = yyt3;
	ey = yyt4;
	s = yyt5;
	b = yyt6;
	eb = yyt7;
	b2 = yyt9;
	s2 = yyt10;
	es2 = yyt8;
	es = yyt6;
	if (yyt6 != NULL) es -= 1;
	eb2 = yyt10;
	if (yyt10 != NULL) eb2 -= 2;
#line 115 "misc/rle.r2c"
	{
      token.x = parse_int(x);
      token.y = parse_int(y);
      if (s != NULL) {
        token.s = mk_string(s, es);
        token.s = mk_string(b, eb);
      } else {
        token.s = mk_string(s2, es2);
        token.s = mk_string(b2, eb2);
      }
      goto ret;
    }
#line 502 "build/rle.c"
yy68:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\n':	goto yy66;
	default:	goto yy14;
	}
yy69:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':
		yyt5 = yyt6 = yyt7 = NULL;
		yyt8 = YYCURSOR;
		goto yy64;
	case '\n':
		yyt5 = yyt6 = yyt7 = NULL;
		yyt8 = YYCURSOR;
		goto yy66;
	case '\r':
		yyt5 = yyt6 = yyt7 = NULL;
		yyt8 = YYCURSOR;
		goto yy68;
	case 'd':	goto yy69;
	default:	goto yy14;
	}
}
#line 127 "misc/rle.r2c"


ret:
  token.next = YYCURSOR;
  return token;
}

int read_file(char *fname) {
  FILE *f = fopen(fname, "rb");
  if (f == NULL) {
    perror(strerror(errno));
    exit(1);
  }
  fseek(f, 0, SEEK_END);
  long fsize = ftell(f);
  char *string = malloc(fsize + 1);
  rewind(f);
  fread(string, 1, fsize + 1, f);
  fclose(f);
  string[fsize] = '\0';
  return string;
}

// typedef struct {
//   char *name;
//   char *creator;
//   u8 stay_alive_rules;
//   u8 birth_rules;
//   int x;
//   int y;
// } rule;

void fprint_rule(FILE *out, rule r) {
  fprintf(out, "  {\n"
    "    .name = \"%s\"\n"
    "    .creator = \"%s\"\n",
  r.name, r.creator);
}

void fprint_rules(FILE *out, int rule_num, rule *rules) {
  fprintf(out, "int rule_num = %d;\n"
    "rule rules[] = {\n");
  for (int i = 0; i < rule_num; i++) {
    fprint_rule(out, rules[i]);
  }
  fprintf(out, "};\n");
}

int main(int argc, char **argv) {
  rule r;
  char *fname = argv[1];
  printf("parsing file %s\n", fname);
  char *file = read_file(fname);
  char *string = file;
  printf("Input file: %s\n", string);

  hash_token t = scan_header(string);
  int header_lines_parsed = 0;
  while (t.type != INVALID) {
    header_lines_parsed++;
    printf("parsed header line %d\n", header_lines_parsed);
    switch (t.type) {
      case NAME:
        r.name = t.name;
        break;
      case AUTHOR:
        r.creator = t.author;
        break;
      case INVALID:
        perror("Coldn't parse file");
        exit(1);
    }
    string = t.next;
    t = scan_header(string);
  }

  fprint_rule(stdout, r);

  free(file);
}
