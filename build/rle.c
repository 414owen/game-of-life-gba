/* Generated by re2c 2.1.1 on Mon Oct 11 16:42:51 2021 */
#line 1 "misc/rle.r2c"
#include <ctype.h>
#include <inttypes.h>
#include <errno.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include "rules.h"

typedef enum {
  NAME,
  AUTHOR,
  XY_RULE,
  INVALID,
} hash_token_type;

typedef struct {
  hash_token_type type;
  char *next;
  union {
    char *name;
    char *author;
    struct {
      unsigned long x;
      unsigned long y;
      uint8_t s;
      uint8_t b;
    };
  };
} hash_token;

static char *mk_string(char *start, char *cursor) {
  int len = cursor - start - 1;
  char *res = malloc(len);
  memcpy(res, start, len);
  res[len] = '\0';
  return res;
}

long parse_int(char *s) {
  bool neg = false;
  long res = 0;
  while (*s == '-') {
    neg = !neg;
  }
  while (isdigit(*s)) {
    res *= 10;
    res += (*s) - '0';
    s++;
  }
  if (neg) res = -res;
  return res;
}

uint8_t parse_rule_bitset(char *s, char *end) {
  uint8_t res = 0;
  while (s < end) {
    int n = *s - '0';
    res |= 1 << n;
    s++;
  }
  return res;
}

uint8_t normal_s = 0;
uint8_t normal_b = 0;

hash_token scan_header(const char *YYCURSOR) {
  char *YYMARKER;
  // union {
  //   struct { char *name, *ename; };
  //   struct { char *author, *eauthor; };
  //   struct { char *x, *y, *rule, *ex, *ey, *erule; };
  // } positions;
  char *name, *ename;
  char *author, *eauthor;
  char *x, *y, *ex, *ey;
  char *s, *b, *es, *eb;
  const char *yyt1; const char *yyt2; const char *yyt3; const char *yyt4; const char *yyt5; const char *yyt6; const char *yyt7; 
  hash_token token;
  token.type = INVALID;
loop:

#line 89 "build/rle.c"
{
	char yych;
	yych = *YYCURSOR;
	switch (yych) {
	case '#':	goto yy4;
	case 'x':	goto yy5;
	default:	goto yy2;
	}
yy2:
	++YYCURSOR;
yy3:
#line 100 "misc/rle.r2c"
	{
      token.type = INVALID;
      goto ret;
    }
#line 106 "build/rle.c"
yy4:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'C':
	case 'c':	goto yy6;
	case 'N':	goto yy8;
	case 'O':	goto yy10;
	default:	goto yy3;
	}
yy5:
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case '\t':
	case ' ':	goto yy12;
	case '=':	goto yy15;
	default:	goto yy3;
	}
yy6:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\n':	goto yy17;
	default:	goto yy6;
	}
yy8:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy8;
	case '\n':
		yyt1 = yyt2 = YYCURSOR;
		goto yy21;
	default:
		yyt1 = YYCURSOR;
		goto yy19;
	}
yy10:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy10;
	case '\n':
		yyt1 = yyt2 = YYCURSOR;
		goto yy26;
	default:
		yyt1 = YYCURSOR;
		goto yy24;
	}
yy12:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy12;
	case '=':	goto yy15;
	default:	goto yy14;
	}
yy14:
	YYCURSOR = YYMARKER;
	goto yy3;
yy15:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy15;
	case '-':
		yyt1 = YYCURSOR;
		goto yy29;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
		yyt1 = YYCURSOR;
		goto yy31;
	default:	goto yy14;
	}
yy17:
	++YYCURSOR;
#line 105 "misc/rle.r2c"
	{ printf("skipping comment\n"); goto loop; }
#line 191 "build/rle.c"
yy19:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\n':
		yyt2 = YYCURSOR;
		goto yy21;
	default:	goto yy19;
	}
yy21:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\n':
	case '\r':	goto yy21;
	default:	goto yy23;
	}
yy23:
	name = yyt1;
	ename = yyt2;
#line 107 "misc/rle.r2c"
	{
      token.type = NAME;
      token.name = mk_string(name, ename);
      goto ret;
    }
#line 216 "build/rle.c"
yy24:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\n':
		yyt2 = YYCURSOR;
		goto yy26;
	default:	goto yy24;
	}
yy26:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\n':
	case '\r':	goto yy26;
	default:	goto yy28;
	}
yy28:
	author = yyt1;
	eauthor = yyt2;
#line 113 "misc/rle.r2c"
	{
      token.type = AUTHOR;
      token.author = mk_string(author, eauthor);
      goto ret;
    }
#line 241 "build/rle.c"
yy29:
	yych = *++YYCURSOR;
	switch (yych) {
	case '-':	goto yy29;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy31;
	default:	goto yy14;
	}
yy31:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':
		yyt2 = YYCURSOR;
		goto yy33;
	case ',':
		yyt2 = YYCURSOR;
		goto yy35;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy31;
	default:	goto yy14;
	}
yy33:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy33;
	case ',':	goto yy35;
	default:	goto yy14;
	}
yy35:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy35;
	case 'y':	goto yy37;
	default:	goto yy14;
	}
yy37:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy37;
	case '=':	goto yy39;
	default:	goto yy14;
	}
yy39:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy39;
	case '-':
		yyt3 = YYCURSOR;
		goto yy41;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
		yyt3 = YYCURSOR;
		goto yy43;
	default:	goto yy14;
	}
yy41:
	yych = *++YYCURSOR;
	switch (yych) {
	case '-':	goto yy41;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy43;
	default:	goto yy14;
	}
yy43:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':
		yyt4 = YYCURSOR;
		goto yy45;
	case '\n':
	case '\r':
		yyt4 = YYCURSOR;
		goto yy47;
	case ',':
		yyt4 = YYCURSOR;
		goto yy50;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy43;
	default:	goto yy14;
	}
yy45:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy45;
	case '\n':
	case '\r':	goto yy47;
	case ',':	goto yy50;
	default:	goto yy14;
	}
yy47:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\n':
	case '\r':	goto yy47;
	default:	goto yy49;
	}
yy49:
	x = yyt1;
	ex = yyt2;
	y = yyt3;
	ey = yyt4;
#line 120 "misc/rle.r2c"
	{
      token.type = XY_RULE;
      token.x = parse_int(x);
      token.y = parse_int(y);
      token.s = normal_s;
      token.b = normal_b;
      goto ret;
    }
#line 399 "build/rle.c"
yy50:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy50;
	case 'R':
	case 'r':	goto yy52;
	default:	goto yy14;
	}
yy52:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'U':
	case 'u':	goto yy53;
	default:	goto yy14;
	}
yy53:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'L':
	case 'l':	goto yy54;
	default:	goto yy14;
	}
yy54:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'E':
	case 'e':	goto yy55;
	default:	goto yy14;
	}
yy55:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy55;
	case '=':	goto yy57;
	default:	goto yy14;
	}
yy57:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy57;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
		yyt5 = YYCURSOR;
		goto yy59;
	case 'B':	goto yy61;
	default:	goto yy14;
	}
yy59:
	yych = *++YYCURSOR;
	switch (yych) {
	case '/':	goto yy62;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy59;
	default:	goto yy14;
	}
yy61:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
		yyt5 = YYCURSOR;
		goto yy63;
	default:	goto yy14;
	}
yy62:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
		yyt6 = YYCURSOR;
		goto yy65;
	default:	goto yy14;
	}
yy63:
	yych = *++YYCURSOR;
	switch (yych) {
	case '/':	goto yy67;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy63;
	default:	goto yy14;
	}
yy65:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':
		yyt7 = YYCURSOR;
		goto yy68;
	case '\n':
	case '\r':
		yyt7 = YYCURSOR;
		goto yy70;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy65;
	default:	goto yy14;
	}
yy67:
	yych = *++YYCURSOR;
	switch (yych) {
	case 'S':	goto yy73;
	default:	goto yy14;
	}
yy68:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy68;
	case '\n':
	case '\r':	goto yy70;
	default:	goto yy14;
	}
yy70:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\n':
	case '\r':	goto yy70;
	default:	goto yy72;
	}
yy72:
	x = yyt1;
	ex = yyt2;
	y = yyt3;
	ey = yyt4;
	s = yyt5;
	b = yyt6;
	eb = yyt7;
	es = yyt6 - 1;
#line 131 "misc/rle.r2c"
	{
      token.type = XY_RULE;
      token.x = parse_int(x);
      token.y = parse_int(y);
      token.s = parse_rule_bitset(s, es);
      token.b = parse_rule_bitset(b, eb);
      goto ret;
    }
#line 587 "build/rle.c"
yy73:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
		yyt6 = YYCURSOR;
		goto yy74;
	default:	goto yy14;
	}
yy74:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':
		yyt7 = YYCURSOR;
		goto yy76;
	case '\n':
	case '\r':
		yyt7 = YYCURSOR;
		goto yy78;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy74;
	default:	goto yy14;
	}
yy76:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\t':
	case ' ':	goto yy76;
	case '\n':
	case '\r':	goto yy78;
	default:	goto yy14;
	}
yy78:
	yych = *++YYCURSOR;
	switch (yych) {
	case '\n':
	case '\r':	goto yy78;
	default:	goto yy80;
	}
yy80:
	x = yyt1;
	ex = yyt2;
	y = yyt3;
	ey = yyt4;
	b = yyt5;
	s = yyt6;
	es = yyt7;
	eb = yyt6 - 2;
#line 142 "misc/rle.r2c"
	{
      token.type = XY_RULE;
      token.x = parse_int(x);
      token.y = parse_int(y);
      token.s = parse_rule_bitset(s, es);
      token.b = parse_rule_bitset(b, eb);
      goto ret;
    }
#line 662 "build/rle.c"
}
#line 151 "misc/rle.r2c"


ret:
  token.next = YYCURSOR;
  return token;
}

int read_file(char *fname) {
  FILE *f = fopen(fname, "rb");
  if (f == NULL) {
    perror(strerror(errno));
    exit(1);
  }
  fseek(f, 0, SEEK_END);
  long fsize = ftell(f);
  char *string = malloc(fsize + 1);
  rewind(f);
  fread(string, 1, fsize + 1, f);
  fclose(f);
  string[fsize] = '\0';
  return string;
}

// typedef struct {
//   char *name;
//   char *creator;
//   u8 stay_alive_rules;
//   u8 birth_rules;
//   int x;
//   int y;
// } rule;

void fprint_rule(FILE *out, rule r) {
  fprintf(out, "  {\n"
    "    .name = \"%s\",\n"
    "    .creator = \"%s\",\n"
    "    .birth_rules = %" PRIu8 ",\n"
    "    .stay_alive_rules = %" PRIu8 ",\n"
    "    .x = %ul,\n"
    "    .y = %ul,\n"
    "  }\n",
    r.name,
    r.creator,
    r.birth_rules,
    r.stay_alive_rules,
    r.x,
    r.y
  );
}

void fprint_rules(FILE *out, int rule_amt, rule *rules) {
  fprintf(out, "int rule_amt = %d;\n"
    "rule rules[] = {\n");
  for (int i = 0; i < rule_amt; i++) {
    fprint_rule(out, rules[i]);
  }
  fprintf(out, "};\n");
}

int main(int argc, char **argv) {
  rule r;
  char *fname = argv[1];
  printf("parsing file %s\n", fname);
  char *file = read_file(fname);
  char *string = file;
  printf("Input file: %s\n", string);

  // init normal rules
  char *ss = "23";
  char *bs = "3";
  normal_s = parse_rule_bitset(ss, ss+2);
  normal_b = parse_rule_bitset(bs, bs+1);

  hash_token t = scan_header(string);
  int header_lines_parsed = 0;
  while (t.type != INVALID) {
    header_lines_parsed++;
    printf("parsed header line %d\n", header_lines_parsed);
    switch (t.type) {
      case NAME:
        r.name = t.name;
        break;
      case AUTHOR:
        r.creator = t.author;
        break;
      case XY_RULE:
        printf("RULE\n");
        r.x = t.x;
        r.y = t.y;
        r.stay_alive_rules = t.s;
        r.birth_rules = t.b;
        break;
      case INVALID:
        perror("Coldn't parse file");
        exit(1);
    }
    string = t.next;
    t = scan_header(string);
  }

  fprint_rule(stdout, r);

  free(file);
}
